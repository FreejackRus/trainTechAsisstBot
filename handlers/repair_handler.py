import logging
import re
from datetime import datetime as dt_datetime
from typing import Union

from aiogram import Router, F
from aiogram.fsm.context import FSMContext
from aiogram.types import InlineKeyboardButton, InlineKeyboardMarkup, Message, CallbackQuery

import config
from glpi_api import connect
from keyboards.inline_kb import get_checkbox_kb_with_other, get_cancel_kb, get_return_main_menu_kb
from states.repair_states import ClaimRepair
from utils.helpers import load_train_list, is_wagon_sn_valid

router = Router()

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ª–æ–≥–≥–µ—Ä–∞
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
ITEMS_PER_PAGE = 5
PROBLEMS_REPAIR = [
    "–ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω –ø–æ—Ä—Ç–∞–ª",
    "–ù–µ–¥–æ—Å—Ç—É–ø–Ω–∞ wi-fi —Å–µ—Ç—å ¬´–¢–∞–≤—Ä–∏—è.–ú–µ–¥–∏–∞¬ª",
]

# –ò–Ω–¥–µ–∫—Å –¥–ª—è "–ò–Ω–æ–µ" (–≤–Ω–µ –¥–∏–∞–ø–∞–∑–æ–Ω–∞ PROBLEMS_REPAIR)
OTHER_OPTION_INDEX = len(PROBLEMS_REPAIR)


async def show_repair_summary(message: Union[Message, CallbackQuery], state: FSMContext):
    if isinstance(message, CallbackQuery):
        message = message.message

    data = await state.get_data()

    # –ü–æ–ª—É—á–∞–µ–º –ª–∏–±–æ –≤–≤–µ–¥—ë–Ω–Ω—É—é –≤—Ä—É—á–Ω—É—é –ø—Ä–æ–±–ª–µ–º—É, –ª–∏–±–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ –∏–∑ —Å–ø–∏—Å–∫–∞
    manual_problem = data.get("manual_problem")
    selected_problems = data.get("selected_problems", [])

    problem_display = "-"

    if manual_problem:
        # –ï—Å–ª–∏ –µ—Å—Ç—å –≤—Ä—É—á–Ω—É—é –≤–≤–µ–¥—ë–Ω–Ω–∞—è –ø—Ä–æ–±–ª–µ–º–∞ ‚Äî –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—ë
        problem_display = manual_problem
    elif isinstance(selected_problems, list):
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–≤–ø–∞–¥–∞—é—Ç —Å PROBLEMS_REPAIR
        valid_problems = [PROBLEMS_REPAIR[i] for i in selected_problems if i < len(PROBLEMS_REPAIR)]
        if valid_problems:
            problem_display = ", ".join(valid_problems)
        else:
            problem_display = "-"

    summary = (
        "üìÑ *–ò—Ç–æ–≥–æ–≤–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –∑–∞—è–≤–∫–µ*\n"
        f"–¢–∏–ø –∑–∞—è–≤–∫–∏: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã\n"
        f"–ó–∞—è–≤–∏—Ç–µ–ª—å: {data.get('executor_name', '-')}\n"
        f"–ü–æ–µ–∑–¥ ‚Ññ: {data.get('train_number', '-')}\n"
        f"–ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {data.get('wagon_number', '-')}\n"
        f"–°–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {data.get('wagon_sn', '-')}\n"
        f"–ü—Ä–æ–±–ª–µ–º—ã: {problem_display}\n"
    )

    confirm_kb = InlineKeyboardMarkup(inline_keyboard=[
        [InlineKeyboardButton(text="–°–æ–∑–¥–∞—Ç—å –∑–∞—è–≤–∫—É", callback_data="create_repair_claim")],
        [InlineKeyboardButton(text="–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å", callback_data="edit_start")]
    ])

    await state.set_state(ClaimRepair.confirmation)
    await message.answer(summary, reply_markup=confirm_kb, parse_mode="Markdown")

async def show_train_page(callback: CallbackQuery, state: FSMContext, page: int):
    data = await state.get_data()
    trains = data.get("trains", [])
    start_index = page * ITEMS_PER_PAGE
    end_index = min(start_index + ITEMS_PER_PAGE, len(trains))
    current_page_trains = trains[start_index:end_index]
    keyboard_buttons = [
        [InlineKeyboardButton(text=f"üöÜ –ü–æ–µ–∑–¥ ‚Ññ{train}", callback_data=f"train_{train}")]
        for train in current_page_trains
    ]
    nav_buttons = []
    if page > 0:
        nav_buttons.append(InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"page_prev_{page - 1}"))
    if end_index < len(trains):
        nav_buttons.append(InlineKeyboardButton(text="–í–ø–µ—Ä—ë–¥ ‚û°Ô∏è", callback_data=f"page_next_{page + 1}"))
    keyboard_buttons.append([InlineKeyboardButton(text="üîç –ü–æ–∏—Å–∫ –ø–æ–µ–∑–¥–∞", callback_data="search_train")])
    if nav_buttons:
        keyboard_buttons.append(nav_buttons)
    await callback.message.edit_reply_markup(reply_markup=InlineKeyboardMarkup(inline_keyboard=keyboard_buttons))


async def process_common_field(message: Message, state: FSMContext,
                               field_name: str, next_state,
                               validation_func=None, error_msg=None):
    value = message.text.strip()
    if validation_func and not validation_func(value):
        await message.answer(error_msg)
        return False
    await state.update_data({field_name: value})
    logger.info(f"State data after update for {field_name}: {await state.get_data()}")
    if field_name == "wagon_number":
        await message.answer(f"‚úÖ –ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {value}")
    elif field_name == "wagon_sn":
        await message.answer(f"‚úÖ –°–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {value}")
    elif field_name == "selected_problems":
        await message.answer(f"‚úÖ –í—ã–±—Ä–∞–Ω–Ω—ã–µ –ø—Ä–æ–±–ª–µ–º—ã: {value}")
    elif field_name == "manual_problem":
        await message.answer(f"‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ (–≤—Ä—É—á–Ω—É—é): {value}")
    data = await state.get_data()
    if data.get('editing'):
        await state.update_data(editing=False)
        await show_repair_summary(message, state)
    else:
        await state.set_state(next_state)
        return True
    return False


@router.callback_query(F.data == "claim_type_restoration")
async def handle_restoration(callback: CallbackQuery, state: FSMContext):
    await state.clear()
    await state.set_state(ClaimRepair.train_number)
    trains = load_train_list()
    if not trains:
        await callback.message.answer("‚ùå –°–ø–∏—Å–æ–∫ –ø–æ–µ–∑–¥–æ–≤ –ø—É—Å—Ç –∏–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return
    await state.update_data(trains=trains, page=0)
    await callback.message.answer("üîß –í—ã –≤—ã–±—Ä–∞–ª–∏: –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–æ—Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç–∏")
    await show_train_page(callback, state, 0)
    await callback.answer()


@router.callback_query(F.data.startswith("page_prev_") | F.data.startswith("page_next_"))
async def navigate_pages(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    page = int(callback.data.split("_")[-1])
    total_pages = (len(data.get("trains", [])) + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE
    if 0 <= page < total_pages:
        await state.update_data(page=page)
        await show_train_page(callback, state, page)


@router.callback_query(F.data == "search_train")
async def open_search_train(callback: CallbackQuery, state: FSMContext):
    await callback.message.answer("–í–≤–µ–¥–∏—Ç–µ —á–∞—Å—Ç—å –Ω–æ–º–µ—Ä–∞ –ø–æ–µ–∑–¥–∞ –¥–ª—è –ø–æ–∏—Å–∫–∞:")
    await state.set_state(ClaimRepair.train_number)
    await callback.answer()


@router.callback_query(F.data.startswith("train_"))
async def select_train(callback: CallbackQuery, state: FSMContext):
    train_number = callback.data.split("_", 1)[1]
    await state.update_data(train_number=train_number)
    await callback.message.answer(f"‚úÖ –ù–æ–º–µ—Ä –ø–æ–µ–∑–¥–∞: {train_number}")
    data = await state.get_data()
    if data.get('editing'):
        await show_repair_summary(callback, state)
    else:
        await state.set_state(ClaimRepair.wagon_number)
        await callback.message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞:", reply_markup=get_cancel_kb())
    await callback.answer()


@router.message(ClaimRepair.train_number)
async def search_train(message: Message, state: FSMContext):
    query = message.text.strip().upper()
    trains = load_train_list()
    results = [t for t in trains if t.upper().startswith(query)]
    if not results:
        await message.answer("‚ùå –ü–æ –≤–∞—à–µ–º—É –∑–∞–ø—Ä–æ—Å—É –ø–æ–µ–∑–¥–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.")
        return
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–µ–∑–¥ –∏–∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ–∏—Å–∫–∞:",
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text=train, callback_data=f"train_{train}")]
            for train in results[:10]
        ])
    )


@router.message(ClaimRepair.wagon_number)
async def repair_wagon_sn(message: Message, state: FSMContext):
    def validate_wagon(value: str) -> bool:
        if not value.isdigit():
            return False
        number = int(value)
        return 1 <= number <= 26

    if not await process_common_field(
        message,
        state,
        "wagon_number",
        ClaimRepair.wagon_sn,
        validation_func=validate_wagon,
        error_msg="‚ùå –ù–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å —á–∏—Å–ª–æ–º –æ—Ç 1 –¥–æ 26."
    ):
        return
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞:", reply_markup=get_cancel_kb())


@router.message(ClaimRepair.wagon_sn)
async def repair_wagon_sn(message: Message, state: FSMContext):
    raw_input = message.text.strip()
    if ' ' not in raw_input:
        if len(raw_input) == 8:
            wagon_sn = f"{raw_input[:3]} {raw_input[3:]}"
        else:
            await message.answer(
                "‚ùå –ù–µ–≤–µ—Ä–Ω–∞—è –¥–ª–∏–Ω–∞ —Å–µ—Ä–∏–π–Ω–æ–≥–æ –Ω–æ–º–µ—Ä–∞.\n"
                "–í–≤–µ–¥–∏—Ç–µ 8 —Å–∏–º–≤–æ–ª–æ–≤ (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1123456), –∏–ª–∏ —Å –ø—Ä–æ–±–µ–ª–æ–º: 112 13456."
            )
            return
    else:
        wagon_sn = raw_input

    await state.update_data(wagon_sn=wagon_sn)
    logger.info(f"State data after wagon_sn update: {await state.get_data()}")

    if not await is_wagon_sn_valid(wagon_sn):
        await message.answer("‚ùå –í–∞–≥–æ–Ω —Å —Ç–∞–∫–∏–º —Å–µ—Ä–∏–π–Ω—ã–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ.\n–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç—å –≤–≤–æ–¥–∞.")
        return

    await message.answer(f"‚úÖ –°–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {wagon_sn}")
    data = await state.get_data()
    selected = data.get("selected_problems", [])
    await message.answer(
        "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ–±–ª–µ–º:",
        reply_markup=get_checkbox_kb_with_other(PROBLEMS_REPAIR, selected, prefix="repair")
    )


@router.callback_query(F.data == "repair_other_manual")
async def handle_repair_other_manual(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    selected = data.get("selected_problems", [])
    selected.clear()
    await state.update_data(selected_problems=selected)
    await callback.message.answer("–í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –≤—Ä—É—á–Ω—É—é:")
    await state.set_state(ClaimRepair.problem_other)
    await callback.answer()


@router.message(ClaimRepair.problem_other)
async def repair_manual_problem(message: Message, state: FSMContext):
    if message.text.strip().lower() == "–æ—Ç–º–µ–Ω–∞":
        data = await state.get_data()
        selected = data.get("selected_problems", [])
        await message.answer(
            "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–Ω—É –∏–ª–∏ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø—Ä–æ–±–ª–µ–º:",
            reply_markup=get_checkbox_kb_with_other(PROBLEMS_REPAIR, selected, prefix="repair")
        )
        await state.set_state(ClaimRepair.confirmation)
        return

    if not await process_common_field(
        message,
        state,
        "manual_problem",
        None,
        None,
        None
    ):
        return

    data = await state.get_data()
    manual_problem = data.get("manual_problem")
    await state.update_data(
        problem_types=[manual_problem],
        selected_problems=[OTHER_OPTION_INDEX]
    )
    await state.set_state(ClaimRepair.executor_name)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –§–ò–û –∑–∞—è–≤–∏—Ç–µ–ª—è:")


@router.callback_query(F.data.regexp(r"^repair_check_\d+$"))
async def handle_repair_check(callback: CallbackQuery, state: FSMContext):
    index = int(callback.data.split("_")[2])
    data = await state.get_data()
    selected = data.get("selected_problems", [])

    if index == OTHER_OPTION_INDEX:
        selected = [index]
    else:
        if OTHER_OPTION_INDEX in selected:
            selected.remove(OTHER_OPTION_INDEX)
        if index in selected:
            selected.remove(index)
        else:
            selected.append(index)

    await state.update_data(selected_problems=selected)
    await callback.message.edit_reply_markup(
        reply_markup=get_checkbox_kb_with_other(PROBLEMS_REPAIR, selected, prefix="repair")
    )


@router.callback_query(F.data == "repair_done")
async def finish_repair_problems(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    selected_indices = data.get("selected_problems", [])
    manual_problem = data.get("manual_problem")

    problem_types = []

    if OTHER_OPTION_INDEX in selected_indices:
        if not manual_problem:
            await callback.answer("‚ùó –í–≤–µ–¥–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –≤—Ä—É—á–Ω—É—é.", show_alert=True)
            return
        problem_types.append(manual_problem)
        selected_indices = [OTHER_OPTION_INDEX]
    else:
        for idx in selected_indices:
            if 0 <= idx < len(PROBLEMS_REPAIR):
                problem_types.append(PROBLEMS_REPAIR[idx])

    if not problem_types:
        await callback.answer("‚ùó –í—ã–±–µ—Ä–∏—Ç–µ —Ö–æ—Ç—è –±—ã –æ–¥–Ω—É –ø—Ä–æ–±–ª–µ–º—É.", show_alert=True)
        return

    await state.update_data(
        problem_types=problem_types,
        selected_problems=selected_indices
    )

    if data.get('editing'):
        await state.update_data(editing=False)
        await show_repair_summary(callback, state)
    else:
        await callback.message.answer(f"‚úÖ –ü—Ä–æ–±–ª–µ–º—ã: {', '.join(problem_types)}")
        await state.set_state(ClaimRepair.executor_name)
        await callback.message.answer("–í–≤–µ–¥–∏—Ç–µ –§–ò–û –∑–∞—è–≤–∏—Ç–µ–ª—è:")

    await callback.answer()


@router.message(ClaimRepair.executor_name)
async def repair_executor_position(message: Message, state: FSMContext):
    name = message.text.strip()
    if not validate_executor_name(name):
        await message.answer("‚ùå –í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ –§–ò–û (—Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã –∏ –ø—Ä–æ–±–µ–ª—ã). –ü—Ä–∏–º–µ—Ä: –ò–≤–∞–Ω–æ–≤ –ò–≤–∞–Ω –ò–≤–∞–Ω–æ–≤–∏—á")
        return
    await state.update_data(executor_name=message.text)
    await show_repair_summary(message, state)


@router.callback_query(F.data == "create_repair_claim", ClaimRepair.confirmation)
async def finish_repair(callback: CallbackQuery, state: FSMContext):
    data = await state.get_data()
    logger.info("–ù–∞—á–∏–Ω–∞–µ–º —Å–æ–∑–¥–∞–Ω–∏–µ –∑–∞—è–≤–∫–∏ –≤ GLPI", extra={"data": data})

    selected_indices = data.get("selected_problems", [])
    manual_problem = data.get("manual_problem")

    problem_types = []
    for idx in selected_indices:
        if 0 <= idx < len(PROBLEMS_REPAIR):
            problem_types.append(PROBLEMS_REPAIR[idx])
    if manual_problem and OTHER_OPTION_INDEX in selected_indices:
        problem_types.append(manual_problem)

    try:
        with connect(config.GLPI_URL, config.GLPI_APP_TOKEN, config.GLPI_USER_TOKEN, False) as glpi:
            logger.debug("–£—Å–ø–µ—à–Ω–æ –ø–æ–¥–∫–ª—é—á–∏–ª–∏—Å—å –∫ GLPI API")
            content = (
                f"–ó–∞—è–≤–∫–∞ —Å–æ–∑–¥–∞–Ω–∞ —á–µ—Ä–µ–∑ Telegram\n"
                "#—Ç–µ–ª–µ–≥—Ä–∞–º\n"
                f"–ü–æ–µ–∑–¥: {data['train_number']}\n"
                f"–í–∞–≥–æ–Ω: {data['wagon_number']}\n"
                f"–°–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {data['wagon_sn']}\n"
                f"–ü—Ä–æ–±–ª–µ–º—ã: {', '.join(data['problem_types'])}\n"
                f"–ó–∞—è–≤–∏—Ç–µ–ª—å: {data['executor_name']}"
            )
            ticket_data = {
                "name": "API GLPI - –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–∞–±–æ—Ç—ã",
                "content": content,
                "urgency": 4,
                "impact": 4,
                "priority": 4,
                "type": 1,
                "requesttypes_id": 8,
                "itilcategories_id": 39,
                "entities_id": 16,
                "_users_id_observer": [22]
            }
            logger.debug("–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –≤ GLPI", extra={"ticket_data": ticket_data})
            ticket_result = glpi.add("Ticket", ticket_data)
            ticket_id = ticket_result[0]['id']
            logger.info(f"–ó–∞—è–≤–∫–∞ —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –≤ GLPI", extra={"ticket_id": ticket_id})
            await callback.message.answer(
                f"‚úÖ –ó–∞—è–≤–∫–∞ ‚Ññ{ticket_id} —É—Å–ø–µ—à–Ω–æ —Å–æ–∑–¥–∞–Ω–∞ –≤ GLPI!\n"
                f"–ü–æ–µ–∑–¥: {data['train_number']}\n"
                f"–í–∞–≥–æ–Ω: {data['wagon_number']}\n"
                f"–°–µ—Ä–∏–π–Ω—ã–π –Ω–æ–º–µ—Ä –≤–∞–≥–æ–Ω–∞: {data['wagon_sn']}",
                reply_markup=get_return_main_menu_kb()
            )
            await state.clear()
    except Exception as e:
        logger.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏ –≤ GLPI", exc_info=True)
        await callback.message.answer(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∑–∞—è–≤–∫–∏: {e}")
        await state.clear()
    await callback.answer()


def validate_executor_name(name: str) -> bool:
    return re.fullmatch(r'^[–∞-—è–ê-–Ø—ë–Åa-zA-Z\s\-]+$', name.strip()) is not None